// use std::fmt::Debug;
//
// /// Represents any mathematical expression
// trait Expression: Debug {
//     fn eval(&self) -> Value;
// }
//
// #[derive(Debug)]
// struct Addition {
//     lhs: i32,
//     rhs: i32,
// }
// impl Addition {
//     fn new(lhs: i32, rhs: i32) -> Self {
//         Self { lhs, rhs }
//     }
// }
// #[derive(Debug)]
// struct Subtraction {
//     lhs: i32,
//     rhs: i32,
// }
// impl Subtraction {
//     fn new(lhs: i32, rhs: i32) -> Self {
//         Self { lhs, rhs }
//     }
// }
//
// #[derive(Debug)]
// /// Multiplication expression
// struct Multiplication {
//     lhs: Value,
//     rhs: Value,
// }
// impl Multiplication {
//     fn new(lhs: Value, rhs: Value) -> Self {
//         Self { lhs, rhs }
//     }
// }
// impl Expression for Multiplication {
//     fn eval(&self) -> Value {}
// }
//
// #[derive(Debug)]
// struct Division {
//     lhs: i32,
//     rhs: i32,
// }
// impl Division {
//     fn new(lhs: i32, rhs: i32) -> Self {
//         Self { lhs, rhs }
//     }
// }
//
// /// An exponential expression
// #[derive(Debug)]
// struct Exponential {
//     base: i32,
//     exp: i32,
// }
// impl Exponential {
//     fn new(base: i32, exp: i32) -> Self {
//         Self { base, exp }
//     }
// }
//
// impl Expression for Addition {
//     fn eval(&self) -> i32 {
//         return self.lhs + self.rhs;
//     }
// }
// impl Expression for Subtraction {
//     fn eval(&self) -> i32 {
//         return self.lhs - self.rhs;
//     }
// }
// // FIXME: int/int must not be an int
// impl Expression for Division {
//     fn eval(&self) -> i32 {
//         return self.lhs / self.rhs;
//     }
// }
// impl Expression for Exponential {
//     fn eval(&self) -> i32 {
//         if self.exp.is_negative() {
//             return Division {
//                 lhs: 1,
//                 // Casting here is safe, because -self.exp is positive
//                 rhs: self.base.pow(-self.exp as u32),
//             }
//             .eval();
//         }
//
//         // Casting here is safe, because self.exp is positive
//         self.base.pow(self.exp as u32)
//     }
// }
//
// fn main() {
//     let expressions: &[Box<dyn Expression>] = &[
//         Box::new(Addition::new(1, 3)),
//         Box::new(Subtraction::new(6, 2)),
//         Box::new(Multiplication::new(9, 8)),
//         Box::new(Division::new(20, 4)),
//         Box::new(Exponential::new(2, 16)),
//         Box::new(Exponential::new(5, -2)),
//     ];
//
//     for expression in expressions {
//         println!("{:?} = {:?}", expression, expression.eval());
//     }
// }
//
// #[derive(Debug)]
// enum Value {
//     Variable { name: String, val: Complex },
//     Constant { val: Complex },
// }
//
// impl Value {
//     /// multiply self by val
//     fn multiply(&self, val: Self) -> Self {
//         match self {
//             Self::Variable { name, val } => todo!("Operations on variables not yet implemented"),
//             Self::Constant { val } => {
//                 if !val.imag.equals(0) {
//                     todo!("Complex numbers with imag != 0 not yet implemented");
//                 }
//
//                 match val.real {
//                     Real::Rational { a, b } => {}
//                     Real::Irrational => {
//                         todo!("Operations on irrational numbers not yet implemented")
//                     }
//                 }
//             }
//         }
//         match val {
//             Self::Constant { val } => {
//                 if !val.imag.equals(0) {
//                     todo!("Complex numbers with imag != 0 not yet implemented");
//                 }
//
//                 match val.real {
//                     Real::Rational { a, b } => {}
//                     Real::Irrational => {
//                         todo!("Operations on irrational numbers not yet implemented")
//                     }
//                 }
//             }
//             Self::Variable { name, val } => todo!(),
//         }
//     }
// }
//
// trait ComplexMul {
//     fn multiply(&self, other: &Complex);
// }
//
// #[derive(Debug)]
// struct Complex {
//     real: Real,
//     imag: Real,
// }
// impl ComplexMul for Complex {
//     fn multiply(&self, other: &Complex) {
//         todo!()
//         // (a + bi)(c + di) = (ac - bd) + (ad + bc)i
//         let ac = self.real.multiply(&other.real);
//         let bd = self.imag.multiply(&other.imag);
//         let ad = self.real.multiply(&other.imag);
//         let bc = self.imag.multiply(&other.real);
//     }
// }
//
// trait RealMul {
//     fn multiply(&self, other: &Real) -> Real;
// }
//
// #[derive(Debug)]
// enum Real {
//     Rational { a: i32, b: i32 },
//     // TODO: implement irrational numbers and operations
//     Irrational,
// }
//
// impl RealMul for Real {
//     fn multiply(&self, other: &Real) -> Real {
//         use Real::*;
//         match (self, other) {
//             // Rational * Rational = Rational
//             (Rational { a: a1, b: b1 }, Rational { a: a2, b: b2 }) => Rational {
//                 a: a1 * a2,
//                 b: b1 * b2,
//             },
//             // Rational * Irrational = Irrational
//             (Rational { .. }, Irrational) | (Irrational, Rational { .. }) => Irrational,
//             // Irrational * Irrational MAY be rational
//             (Irrational, Irrational) => {
//                 todo!("Multiplication of irrational numbers not yet implemented")
//             }
//         }
//     }
// }

use std::fmt::Display;

#[derive(Debug)]
enum Expr {
    Constant(Complex),
    Variable(String),
    Product(Box<Expr>, Box<Expr>),
    Sum(Box<Expr>, Box<Expr>),
}

#[derive(Debug)]
struct Complex {
    real: Real,
    imag: Real,
}
impl Display for Complex {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        // Real part only, omit imaginary component
        if self.imag == Real::zero() {
            return write!(f, "{}", self.real);
        }

        write!(f, "({} + {}i)", self.real, self.imag)
    }
}
impl Complex {
    fn new(real: Real, imag: Real) -> Self {
        Self { real, imag }
    }

    fn multiply(&self, other: &Self) -> Self {
        // (a + bi)(c + di) = (ac - bd) + (ad + bc)i
        let ac = self.real.multiply(&other.real);
        let bd = self.imag.multiply(&other.imag);
        let ad = self.real.multiply(&other.imag);
        let bc = self.imag.multiply(&other.real);

        Complex {
            real: ac.subtract(&bd),
            imag: ad.add(&bc),
        }
    }
}

#[derive(Debug)]
enum Real {
    Rational { num: i64, denom: i64 },
    Irrational,
}
impl PartialEq for Real {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            // Cross-multiply
            (Real::Rational { num: n1, denom: d1 }, Real::Rational { num: n2, denom: d2 }) => {
                n1 * d2 == n2 * d1
            }
            _ => todo!(),
        }
    }
}
impl Display for Real {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Rational { num, denom } => {
                // Omit denominator when it's 1
                if *denom == 1 {
                    return write!(f, "{}", num);
                }

                // Write rational number as a fraction
                write!(f, "({} / {})", num, denom)
            }
            Self::Irrational => todo!(),
        }
    }
}
fn gcd(a: i64, b: i64) -> i64 {
    let mut a = a.abs();
    let mut b = b.abs();

    while b != 0 {
        let temp = b;
        b = a % b;
        a = temp;
    }

    a
}

impl Real {
    // TODO: handle this better without copying??? (keep as constant)
    fn zero() -> Self {
        Self::int(0)
    }
    fn rational(num: i64, denom: i64) -> Self {
        let (n, d) = Self::simplify_rational(num, denom);
        Self::Rational { num, denom }
    }
    fn int(value: i64) -> Self {
        Self::Rational {
            num: value,
            denom: 1,
        }
    }

    pub fn simplify_rational(num: i32, denom: i32) -> (i32, i32) {
        let gcd = gcd(num, denom);
        let sign = if denom < 0 { -1 } else { 1 };
        (sign * num / gcd, sign * denom.abs() / gcd)
    }

    fn add(&self, other: &Self) -> Self {
        match (self, other) {
            (Real::Rational { num: a, denom: b }, Real::Rational { num: c, denom: d }) => {
                let num = a * d + b * c;
                let denom = b * d;
                Real::rational(num, denom)
            }
            _ => todo!(),
        }
    }

    fn subtract(&self, other: &Self) -> Self {
        self.add(&other.negate())
    }

    fn multiply(&self, other: &Self) -> Self {
        match (self, other) {
            (Self::Rational { num: a, denom: b }, Self::Rational { num: c, denom: d }) => {
                Real::rational(a * c, b * d)
            }
            _ => todo!("Operations on irrational numbers not yet supported"),
        }
    }
    fn divide(&self, other: &Self) -> Self {
        match (self, other) {
            (Real::Rational { num: a, denom: b }, Real::Rational { num: c, denom: d }) => {
                // Multiply by the inverse
                Real::rational(a * d, b * c)
            }
            _ => todo!(),
        }
    }

    /// Returns the value * -1
    fn negate(&self) -> Self {
        match self {
            Real::Rational { num, denom } => Real::rational(-num, *denom),
            Real::Irrational => todo!(),
        }
    }
}

fn main() {
    let a = Complex::new(Real::int(5), Real::int(0));
    let b = Complex::new(Real::rational(3, 10), Real::int(0));

    println!("{} * {} = {}", a, b, a.multiply(&b));
    println!("{:?} * {:?} = {:?}", a, b, a.multiply(&b));
}
